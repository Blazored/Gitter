@page "/room"
@page "/room/{roomid}"
@implements IDisposable

<div id="blgmessagelist" class="blg-center scrollable" onscroll="@MessagesScrolled">
	@if (Messages is object)
	{
		<div class="list-group list-group-flush">
			@foreach (var message in Messages.OrderBy(m => m.Sent))
			{
				<div id="@message.Id" class="@MessageClassList(message)">
					<div class="d-flex w-100 justify-content-between">
						<img src="@message.FromUser.AvatarUrlSmall" width="38" height="38" style="border-radius:25%;" />
						<h5 class="mb-1">@message.FromUser.DisplayName</h5>
						<small>@($"@{message.FromUser.Username}")</small>
						<small class="text-muted">@(LocalTime(message.Sent))</small>
					</div>
					<p class="mb-1">
						@(new MarkupString(message.Html))
					</p>
				</div>
			}

		</div>
	}
</div>

<form onsubmit="@SendMessage" class="d-flex align-items-center blg-bottom-center">
	<img src="@State.GetMyUser().AvatarUrlSmall" width="38" height="38" class="rounded-lg mr-1" />
	<textarea id="messageinput"
						class="form-control flex-grow-1"
						bind="@NewMessage"
						placeholder="Join the conversation..." />
	<button type="submit" class="btn btn-primary btn-sm ml-1">Ok</button>
</form>

@functions
{
		[Inject] IUriHelper UriHelper { get; set; }
		[Inject] IJSRuntime JSRuntime { get; set; }
		[Inject] IChatApi GitterApi { get; set; }
		[Inject] ILocalisationHelper Localisation { get; set; }
		[Inject] IAppState State { get; set; }

		[Parameter] protected string RoomId { get; set; }

		CancellationTokenSource tokenSource;
		List<IChatMessage> Messages;
		string NewMessage;
		Task RoomWatcher;
		bool KeepWatching = false;
		bool FirstLoad = true;
		string LastRoom = string.Empty;
		static SemaphoreSlim ssFetch = new SemaphoreSlim(1, 1);
		static SemaphoreSlim ssScroll = new SemaphoreSlim(1, 1);
		bool IsFetchingOlder = false;
		bool NoMoreOldMessages = false;

		protected override async Task OnAfterRenderAsync()
		{
			if (await CheckStateForRedirect())
			{
				UriHelper.NavigateTo("/");
			}
			if (FirstLoad && Messages?.Count > 0)
			{
				FirstLoad = false;
				await JSRuntime.InvokeAsync<object>("eval", $"document.getElementById('{Messages.Last().Id}').scrollIntoView()");
			}
		}

		protected override async Task OnParametersSetAsync()
		{
			await base.OnParametersSetAsync();
			if (!LastRoom.Equals(RoomId))
			{
				FirstLoad = true;
				LastRoom = RoomId;
				NoMoreOldMessages = false;
				IsFetchingOlder = false;
			}
			if (GitterApi is object)
			{
				Console.WriteLine("Loading room...");
				Messages = new List<IChatMessage>();
				await Invoke(StateHasChanged);
				await Task.Delay(1);

				if (!(RoomWatcher is object))
				{
					KeepWatching = true;
					tokenSource = new CancellationTokenSource();
					RoomWatcher = MonitorNewMessages(tokenSource.Token);
				}
			}
		}

		string LocalTime(DateTime dateTime) =>
				TimeZoneInfo
					.ConvertTime(
						dateTime,
						Localisation.LocalTimeZoneInfo
					)
					.ToString(
						"G",
						Localisation.LocalCultureInfo
					);

		string MessageClassList(IChatMessage message) =>
			new BlazorComponentUtilities.CssBuilder()
						.AddClass("list-group-item")
						.AddClass("list-group-item-action")
						.AddClass("flex-column")
						.AddClass("align-items-start")
						.AddClass("bg-inherit")
						.AddClass("text-inherit")
						.AddClass("list-group-item-success", message.Unread)
						.AddClass("list-group-item-warning", message.Mentions.Any(m => m.UserId == State.GetMyUser().Id))
						.Build();

		async Task<bool> CheckStateForRedirect()
		{
			if (string.IsNullOrWhiteSpace(RoomId))
			{
				return true;
			}
			if (!(State is object)) // || !(GitterApi is object))
			{
				return true;
			}
			if (!State.HasChatRooms)
			{
				State.SetMyRooms((await GitterApi.GetChatRooms(State.GetMyUser().Id)).ToList());
			}
			if (!State.HasChatRooms)
			{
				return true;
			}
			return false;
		}

		void SendMessage(UIEventArgs args)
		{
			if (!string.IsNullOrWhiteSpace(NewMessage))
			{
				GitterApi.SendChatMessage(RoomId, NewMessage);
				NewMessage = "";
			}
			return;
		}

		async Task MonitorNewMessages(CancellationToken token)
		{
			var options = GitterApi.GetNewOptions();
			options.Lang = Localisation.LocalCultureInfo.Name;
			while (!token.IsCancellationRequested && KeepWatching)
			{
				options.AfterId = "";
				if (Messages?.Any() ?? false)
				{
					options.AfterId = Messages.OrderBy(m => m.Sent).Last().Id;
				}
				await FetchNewMessages(options, token);
				await Task.Delay(2000, token);
			}
			token.ThrowIfCancellationRequested();
		}

		async Task<int> FetchNewMessages(IChatMessageOptions options, CancellationToken token)
		{
			List<IChatMessage> messages = null;
			int count = 0;
			if (!token.IsCancellationRequested)
			{
				await ssFetch.WaitAsync(token);
				try
				{
					messages = (await GitterApi.GetChatMessages(RoomId, options)).ToList();
					if (messages is object)
					{
						count = messages.Count;
						messages.AddRange(Messages);
						Messages = messages;
						await Invoke(StateHasChanged);
						await Task.Delay(1);
					}
				}
				catch (Exception e)
				{
					Console.WriteLine(e);
				}
				finally
				{
					ssFetch.Release();
				}
			}
			return count;
		}

		async Task<int> FetchOldMessages(CancellationToken token)
		{
			var options = GitterApi.GetNewOptions();
			options.Lang = Localisation.LocalCultureInfo.Name;
			if (!token.IsCancellationRequested && IsFetchingOlder)
			{
				options.AfterId = "";
				if (Messages?.Any() ?? false)
				{
					options.BeforeId = Messages.OrderBy(m => m.Sent).First().Id;
					var count = await FetchNewMessages(options, token);
					await Invoke(StateHasChanged);
					await Task.Delay(100);
					await JSRuntime.InvokeAsync<object>("eval", $"document.getElementById('{options.BeforeId}').scrollIntoView()");
					return count;
				}
			}
			token.ThrowIfCancellationRequested();
			return 0;
		}

		async Task MessagesScrolled(UIEventArgs args)
		{
			if (!NoMoreOldMessages && !IsFetchingOlder && Messages.Any())
			{
				await ssScroll.WaitAsync();
				try
				{

					var scroll = await JSRuntime.InvokeAsync<double>("eval", $"document.getElementById('blgmessagelist').scrollTop");
					if (scroll < 200)
					{
						IsFetchingOlder = true;

						var count = await FetchOldMessages(tokenSource.Token);
						if (count == 0)
						{
							NoMoreOldMessages = true;
						}
						IsFetchingOlder = false;
					}
				}
				catch
				{
				}
				finally
				{
					ssScroll.Release();
				}
			}
		}

		public void Dispose()
		{
			if (tokenSource is object && tokenSource.Token.CanBeCanceled)
			{
				try
				{
					tokenSource.Cancel();
					if (RoomWatcher is object)
					{
						var _ = RoomWatcher?.Wait(2000);
					}
					tokenSource.Dispose();
				}
				catch (Exception e)
				{
					Console.WriteLine(e);
				}
			}
			NoMoreOldMessages = false;
			IsFetchingOlder = false;
		}
}
